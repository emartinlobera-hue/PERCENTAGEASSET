<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Crypto Futures</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18 + ReactDOM + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Firebase (Auth compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>

  <style>
    html,body,#root{height:100%} body{background:#111827;margin:0}
    .overlay{position:fixed;inset:0;display:grid;place-items:center;background:#0b1220;color:#e5e7eb;z-index:99999}
    .card{width:100%;max-width:380px;background:#111827;border:1px solid #374151;border-radius:12px;padding:20px}
    .input{width:100%;padding:10px 12px;border-radius:8px;border:1px solid #374151;background:#0b1220;color:#e5e7eb;outline:none}
    .btn{margin-top:10px;width:100%;padding:10px 12px;border-radius:8px;background:#4f46e5;color:#fff;font-weight:700;border:none;cursor:pointer}
    .err{margin-top:8px;font-size:12px;color:#fca5a5}
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    // Overlay de error visible
    function showFatal(err){
      try{
        const w=document.createElement('div');
        w.style.position='fixed';w.style.inset='0';w.style.background='#0b1220';w.style.color='#fca5a5';w.style.display='grid';w.style.placeItems='center';w.style.zIndex='999999';
        w.innerHTML = "<div style='max-width:680px;background:#111827;border:1px solid #ef4444;border-radius:12px;padding:18px;font-family:system-ui'>"
          + "<h3 style='margin:0 0 6px;font-weight:800;color:#ef4444'>Error al iniciar la app</h3>"
          + "<pre style='white-space:pre-wrap;color:#fca5a5;font-size:12px'>"+(err && (err.stack||err.message||String(err)))+"</pre>"
          + "</div>";
        document.body.appendChild(w);
      }catch(_e){ alert(err?.message||String(err)); }
    }

    // Firebase (lo dejamos tal cual, aunque ya no se usa para login)
    const firebaseConfig={apiKey:"AIzaSyBoGQC6KyAIq202vi4mHQ35ClSKExT9w2I",authDomain:"percentage-db2d5.firebaseapp.com",projectId:"percentage-db2d5",storageBucket:"percentage-db2d5.firebasestorage.app",messagingSenderId:"934110452963",appId:"1:934110452963:web:86310698349cf2367f39d6"};
    try{ if(!firebase.apps?.length) firebase.initializeApp(firebaseConfig);}catch(_){ }

    // Login simplificado: SOLO contraseña "chiva"
    function showLogin(){
      const wrap=document.createElement("div");
      wrap.className="overlay"; wrap.id="loginOverlay";
      wrap.innerHTML=`<div class="card">
        <h1 style="font-size:18px;font-weight:800;margin:0 0 8px;color:#34d399;">Acceso</h1>
        <p style="font-size:14px;color:#9ca3af;margin:0 0 12px;">Introduce la contraseña para acceder.</p>
        <form id="loginForm">
          <input id="loginPass" type="password" placeholder="Contraseña" class="input" required />
          <button type="submit" class="btn">Entrar</button>
          <div id="loginErr" class="err"></div>
        </form>
      </div>`;
      document.body.appendChild(wrap);

      const form=wrap.querySelector("#loginForm");
      const pass=wrap.querySelector("#loginPass");
      const err=wrap.querySelector("#loginErr");

      form.addEventListener("submit",(e)=>{
        e.preventDefault(); err.textContent="";
        try{
          if(pass.value.trim() === 'chiva'){
            wrap.remove(); showDisclaimer();
          } else {
            err.textContent = 'Contraseña incorrecta';
            pass.value = '';
            pass.focus();
          }
        }catch(ex){ err.textContent=String(ex||'Error'); }
      });
    }

    function showDisclaimer(){
      const o=document.createElement("div");
      o.className="overlay"; o.style.background="rgba(0,0,0,.75)"; o.id="disc";
      o.innerHTML=`<div class="card" style="max-width:560px;background:#fff7ed;color:#7c2d12;border-color:#fdba74">
        <h2 style="font-size:18px;font-weight:800;margin-bottom:8px;color:#7c2d12;">Aviso</h2>
        <p style="font-size:14px;line-height:1.5;color:#7c2d12;">“Este contenido tiene únicamente fines educativos e informativos. No constituye asesoramiento financiero ni una recomendación de inversión.”</p>
        <button id="discOk" class="btn" style="background:#ea580c">He leído y acepto</button>
      </div>`;
      document.body.appendChild(o);
      o.querySelector("#discOk").addEventListener("click",()=>{ o.remove(); if(window.__startApp__) window.__startApp__(); });
    }

    showLogin();
  </script>

  <!-- ============= APP (JSX) ============= -->
  <script type="text/babel" data-presets="env,react">
    const { useEffect, useRef, useState } = React;

    /* ===== Utils ===== */
    const fmtNum=(v,d=2)=>v==null||!isFinite(v)?"—":Number(v).toLocaleString(undefined,{maximumFractionDigits:d});
    function pricePrecisionFromValue(p){ if(!isFinite(p)||p<=0) return 2; const e=Math.floor(Math.log10(Math.abs(p))); if(e>=2) return 0; if(e===1) return 1; if(e===0) return 2; return Math.min(8,2+ -e); }
    const fmtDyn=p=>p==null||!isFinite(p)?"—":p.toFixed(pricePrecisionFromValue(p));
    const lastOf=arr=>arr && arr.length ? arr[arr.length-1] : undefined;
    const getJSON=(k,def)=>{try{const raw=localStorage.getItem(k);return raw?JSON.parse(raw):def;}catch{return def;}};
    const setJSON=(k,v)=>localStorage.setItem(k,JSON.stringify(v));
    const LS={LAST:"cf:last",RANGE:"cf:range"};

    async function ensureLW(){
      if(window.LightweightCharts?.createChart) return window.LightweightCharts;
      await new Promise((res,rej)=>{
        const id="lwcharts-cdn";
        if(document.getElementById(id)){document.getElementById(id).addEventListener("load",res,{once:true});document.getElementById(id).addEventListener("error",rej,{once:true});return;}
        const s=document.createElement("script"); s.id=id; s.src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"; s.async=true; s.onload=res; s.onerror=rej; document.head.appendChild(s);
      });
      if(!window.LightweightCharts?.createChart) throw new Error("LightweightCharts error");
      return window.LightweightCharts;
    }

    /* ===== Indicadores ===== */
    const ema=(arr,p)=>{ if(!arr?.length) return []; const out=Array(arr.length).fill(null),k=2/(p+1); let s=0; for(let i=0;i<p&&i<arr.length;i++) s+=arr[i]; if(arr.length>=p) out[p-1]=s/p; for(let i=p;i<arr.length;i++) out[i]=arr[i]*k+out[i-1]*(1-k); return out; };
    const sma=(arr,p)=>{ const out=Array(arr.length).fill(null); let s=0; for(let i=0;i<arr.length;i++){ s+=arr[i]; if(i>=p) s-=arr[i-p]; if(i>=p-1) out[i]=s/p; } return out; };
    const rsi=(arr,p=14)=>{ const out=Array(arr.length).fill(null); if(arr.length<p+1) return out; let g=0,l=0; for(let i=1;i<=p;i++){ const d=arr[i]-arr[i-1]; if(d>=0) g+=d; else l-=d; } let ag=g/p,al=l/p; out[p]=al===0?100:100-100/(1+ag/al); for(let i=p+1;i<arr.length;i++){ const d=arr[i]-arr[i-1]; ag=(ag*(p-1)+(d>0?d:0))/p; al=(al*(p-1)+(d<0?-d:0))/p; out[i]=al===0?100:100-100/(1+ag/al);} return out; };
    const macd=(arr,fast=12,slow=26,signal=9)=>{ const f=ema(arr,fast),s=ema(arr,slow); const line=arr.map((_,i)=>(f[i]!=null&&s[i]!=null?f[i]-s[i]:null)); const sig=ema(line.map(x=>x??0),signal).map((v,i)=>(line[i]==null?null:v)); const hist=line.map((v,i)=>(v==null||sig[i]==null?null:v-sig[i])); return {line,sig,hist}; };
    const atr=(c,p=14)=>{ const tr=[]; for(let i=0;i<c.length;i++){ const k=c[i],pr=c[i-1]; if(!pr){ tr.push(k.high-k.low); continue; } const a=k.high-k.low,b=Math.abs(k.high-pr.close),d=Math.abs(k.low-pr.close); tr.push(Math.max(a,b,d)); } return ema(tr,p); };

    /* ===== Símbolos y TF ===== */
    const ALL_SYMBOLS=["BTCUSDT","ETHUSDT","USDCUSDT","BNBUSDT","XRPUSDT","SOLUSDT","DOGEUSDT","TRXUSDT","ADAUSDT","AVAXUSDT","LTCUSDT","XLMUSDT","LINKUSDT","BCHUSDT","HBARUSDT","SUIUSDT","MATICUSDT","ALGOUSDT","VETUSDT","FILUSDT","ICPUSDT","FLOWUSDT","XTZUSDT","FTMUSDT","EOSUSDT","SANDUSDT","GALAUSDT","AXSUSDT","KSMUSDT","IOTAUSDT","CHZUSDT","MKRUSDT","AAVEUSDT","UNIUSDT","SUSHIUSDT","ARUSDT","QNTUSDT","OPUSDT","BTTCUSDT","DASHUSDT","ZECUSDT","WAVESUSDT","SPKUSDT"];
    const TF_BINANCE={"4H":"4h","1D":"1d","1W":"1w","1M":"1M"};
    const TF_BITGET={"4H":"4hour","1D":"1day","1W":"1week","1M":"1month"};

    /* ===== Fetch ===== */
    async function fetchBinance(symbol,tf){
      const url=`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${TF_BINANCE[tf]}&limit=1000`;
      const r=await fetch(url); if(!r.ok) throw new Error("Binance no disponible o símbolo no listado.");
      const j=await r.json();
      return j.map(k=>({time:k[0]/1000,open:+k[1],high:+k[2],low:+k[3],close:+k[4],volume:+k[5],_ex:"binance"}));
    }
    async function fetchBitget(symbol,tf){
      const url=`https://api.bitget.com/api/spot/v1/market/candles?symbol=${symbol}&period=${TF_BITGET[tf]}&limit=1000`;
      const r=await fetch(url); if(!r.ok) throw new Error("Bitget no disponible o símbolo no listado.");
      const j=await r.json(); const arr=Array.isArray(j?.data)?j.data.slice().reverse():[];
      return arr.map(k=>({time:(+k[0])/1000,open:+k[1],high:+k[2],low:+k[3],close:+k[4],volume:+k[5],_ex:"bitget"}));
    }
    async function fetchCandlesCombined(symbol,tf){
      const res=await Promise.allSettled([fetchBinance(symbol,tf),fetchBitget(symbol,tf)]);
      const ok=res.filter(x=>x.status==="fulfilled").map(x=>x.value).filter(a=>Array.isArray(a)&&a.length>0);
      if(ok.length===0) throw new Error("No hay datos para este símbolo en Binance/Bitget.");
      ok.sort((a,b)=>a[a.length-1].time-b[b.length-1].time);
      return ok[ok.length-1];
    }

    /* ===== Evaluación con 1 TP/SL + Entrada ===== */
    function evaluate(c, tf, htfSide=null){
      if(!c||c.length<80) return {status:"Esperar",reliability:0,bias:"rango",why:["Datos insuficientes."],conflicts:[],missing:[],ema50:null,rsi14:null,macd:null,signal:null,hist:null,recentHigh30:null,recentLow30:null,recentHigh90:null,recentLow90:null,active:null,ideas:[],price:null,tps:null, commentary:""};

      const closes=c.map(x=>x.close), highs=c.map(x=>x.high), lows=c.map(x=>x.low), vols=c.map(x=>x.volume);
      const i=c.length-1, price=closes[i];
      const EMA50=ema(closes,50), RSI14=rsi(closes,14);
      const {line:MACD,sig:SIG,hist:HIST}=macd(closes,12,26,9);
      const VOL20=sma(vols,20), ATR14=atr(c,14);
      const recentHigh30=Math.max(...highs.slice(-30)), recentLow30=Math.min(...lows.slice(-30));
      const recentHigh90=Math.max(...highs.slice(-90)), recentLow90=Math.min(...lows.slice(-90));

      const aboveE = EMA50[i]!=null && price>EMA50[i];
      const emaSlope = EMA50[i]!=null&&EMA50[i-1]!=null ? EMA50[i]-EMA50[i-1] : 0;
      const rsiVal=RSI14[i]; const rsiBull=rsiVal!=null&&rsiVal>50; const rsiBear=rsiVal!=null&&rsiVal<50;
      const macdBull=HIST[i]!=null&&MACD[i]>SIG[i]&&HIST[i]>0; const macdBear=HIST[i]!=null&&MACD[i]<SIG[i]&&HIST[i]<0;
      const volExp=VOL20[i]!=null&&vols[i]>=1.0*VOL20[i];

      let bias="rango";
      if(aboveE&&rsiBull&&macdBull) bias="alcista";
      else if(!aboveE&&rsiBear&&macdBear) bias="bajista";
      else bias=aboveE?"alcista":(EMA50[i]!=null&&price<EMA50[i]?"bajista":"rango");

      const clamp01=x=>Math.max(0,Math.min(1,x));
      const mag=(val,ref)=>clamp01(Math.abs(val)/(Math.abs(ref)||1e-9));
      const macdMagRef=(()=>{const m=HIST.slice(-50).filter(x=>x!=null).map(x=>Math.abs(x)); return m.length?m.reduce((a,b)=>a+b,0)/m.length:1;})();
      const W={emaPos:0.3,emaSlope:0.15,rsi:0.2,macd:0.25,vol:0.1};
      let longScore=(aboveE?W.emaPos:0)+(emaSlope>0?W.emaSlope*clamp01(emaSlope/(price*0.001)):0)+(rsiBull?W.rsi*clamp01((rsiVal-50)/20):0)+(macdBull?W.macd*clamp01(mag(HIST[i],macdMagRef)):0)+(volExp?W.vol*clamp01(vols[i]/(VOL20[i]||1e-9)):0);
      let shortScore=(!aboveE?W.emaPos:0)+(emaSlope<0?W.emaSlope*clamp01(-emaSlope/(price*0.001)):0)+(rsiBear?W.rsi*clamp01((50-rsiVal)/20):0)+(macdBear?W.macd*clamp01(mag(HIST[i],macdMagRef)):0)+(volExp?W.vol*clamp01(vols[i]/(VOL20[i]||1e-9)):0);

      // Alineación con 1D (HTF)
      if(htfSide==="Long") longScore += 0.15;
      if(htfSide==="Short") shortScore += 0.15;

      let sideChoice=longScore>=shortScore?"Long":"Short";
      let reliability=clamp01(Math.max(longScore,shortScore));

      if(htfSide && sideChoice!==htfSide){
        reliability = clamp01(reliability - 0.20);
        if(reliability < 0.50) sideChoice = htfSide;
      } else if(htfSide && sideChoice===htfSide){
        reliability = clamp01(reliability + 0.15);
      }

      // SL/TP
      const kATR=tf==="1D"?1.2:1.0, bufferMul=0.5, minPct=0.008, maxPct=0.035;
      const atrVal = ATR14[i] ?? price*0.01;

      function clampDistance(entry,side,sl){
        const minDist=entry*minPct, maxDist=entry*maxPct;
        let dist=Math.abs(entry-sl), outSL=sl;
        if(dist<minDist) outSL = side==="Long" ? entry-minDist : entry+minDist;
        dist = Math.abs(entry-outSL);
        if(dist>maxDist) outSL = side==="Long" ? entry-maxDist : entry+maxDist;
        return outSL;
      }

      function calcSide(side){
        const entry=price, k=kATR*atrVal, buffer=bufferMul*atrVal;
        let SL_struct = side==="Long" ? Math.min(recentLow30, entry) - buffer
                                      : Math.max(recentHigh30, entry) + buffer;
        let SL_vol    = side==="Long" ? entry - k : entry + k;
        let SL = side==="Long" ? Math.max(SL_struct, SL_vol) : Math.min(SL_struct, SL_vol);
        SL = clampDistance(entry, side, SL);

        const R = Math.abs(entry - SL);
        let TP2R = side==="Long" ? entry + 2*R : entry - 2*R;
        let LVL  = side==="Long" ? Math.max(entry, recentHigh30) : Math.min(entry, recentLow30);
        let TP   = 0.6*TP2R + 0.4*LVL;
        const lim = side==="Long" ? recentHigh90 : recentLow90;
        if(side==="Long") TP = Math.min(TP, lim); else TP = Math.max(TP, lim);
        if(!isFinite(TP) || Math.abs(TP-entry)<entry*0.001) TP = side==="Long" ? entry + Math.max(R, entry*minPct) : entry - Math.max(R, entry*minPct);

        const rr = side==="Long" ? (TP-entry)/(entry-SL) : (entry-TP)/(SL-entry);
        return {entry, SL, TP, R, rr};
      }

      const res = calcSide(sideChoice);
      const active={side:sideChoice, entry:res.entry, sl:res.SL, tp:res.TP, rr:res.rr,
        text:`Señal: ${sideChoice} — SL ${fmtDyn(res.SL)} / TP ${fmtDyn(res.TP)}`
      };
      const tps={TP:res.TP, SL:res.SL};

      const pros=[],conflicts=[],missing=[];
      const rsiValNow=rsiVal;
      if(EMA50[i]!=null && price>EMA50[i]) pros.push(`Precio > EMA50 (${fmtDyn(price)} > ${fmtDyn(EMA50[i])})`);
      else if(EMA50[i]!=null && price<EMA50[i]) pros.push(`Precio < EMA50 (${fmtDyn(price)} < ${fmtDyn(EMA50[i])})`);
      if(emaSlope>0) pros.push("EMA50 subiendo."); if(emaSlope<0) pros.push("EMA50 cayendo.");
      if(rsiValNow!=null && rsiValNow>50) pros.push(`RSI(14) ${fmtDyn(rsiValNow)} > 50`); else if(rsiValNow!=null && rsiValNow<50) pros.push(`RSI(14) ${fmtDyn(rsiValNow)} < 50`); else missing.push("RSI sin dirección clara");
      if(macdBull) pros.push("MACD>señal, hist>0"); else if(macdBear) pros.push("MACD<señal, hist<0"); else missing.push("MACD sin impulso claro");
      if(volExp) pros.push("Volumen ≥ SMA20"); else missing.push("Volumen sin expansión");
      if(EMA50[i]!=null && price>EMA50[i]&&(macdBear||rsiBear)) conflicts.push("Precio > EMA50 pero impulso bajista (RSI/MACD)");
      if(EMA50[i]!=null && price<EMA50[i]&&(macdBull||rsiBull)) conflicts.push("Precio < EMA50 pero impulso alcista (RSI/MACD)");

      function mkComment({ side, bias, emaSlope, rsiVal, macdBull, macdBear, volExp, htfSide, aligned }) {
        const dir = side === "Long" ? "comprador" : "vendedor";
        const trend = emaSlope > 0 ? "EMA50 ascendente" : emaSlope < 0 ? "EMA50 descendente" : "EMA50 plana";
        const rsiTxt =
          rsiVal == null ? "RSI sin lectura" :
          (side === "Long"
            ? (rsiVal >= 60 ? "RSI firme (>60)" : rsiVal > 50 ? "RSI sobre 50" : "RSI cercano a 50")
            : (rsiVal <= 40 ? "RSI débil (<40)" : rsiVal < 50 ? "RSI bajo 50" : "RSI cercano a 50"));
        const macdTxt =
          macdBull ? "MACD por encima de señal (hist. positivo)" :
          macdBear ? "MACD por debajo de señal (hist. negativo)" :
          "MACD sin ventaja";
        const volTxt = volExp ? "volumen acompaña" : "volumen sin expansión";
        const htfTxt = !htfSide ? "sin referencia de 1D" : aligned ? "alineado con 1D" : "en contra de 1D (ajustado)";
        const mgmt = side==="Long" ? "SL bajo estructura + ATR; TP media entre 2R y resistencia" : "SL sobre estructura + ATR; TP media entre 2R y soporte";
        return `Sesgo ${bias} con sesgo ${dir}: ${trend}; ${rsiTxt}. ${macdTxt}; ${volTxt}; ${htfTxt}. Gestión: ${mgmt}.`;
      }
      const aligned = htfSide ? ((active?.side||sideChoice)===htfSide) : false;
      const commentary = mkComment({side:active.side,bias,emaSlope,rsiVal:rsiValNow,macdBull,macdBear,volExp,htfSide,aligned});

      const ideas=[];
      function idea(side){
        const r=calcSide(side);
        const rel = side===sideChoice ? reliability : Math.max(0.35, reliability*0.6);
        ideas.push({dir:side+" (market)", entry:r.entry, sl:r.SL, tp:r.TP, rr:r.rr, reliability:rel, note:"TP media (2R + nivel), SL humano"});
      }
      idea("Long"); idea("Short");

      return {status:sideChoice,reliability,bias,why:pros,conflicts,missing,ema50:EMA50[i],rsi14:RSI14[i],macd:MACD[i],signal:SIG[i],hist:HIST[i],recentHigh30,recentLow30,recentHigh90,recentLow90,active,ideas,price, tps, commentary};
    }

    function App(){
      const last=getJSON(LS.LAST,{symbol:"BTCUSDT",tf:"4H"});
      const [symbol,setSymbol]=useState(last.symbol);
      const [tf,setTf]=useState(last.tf);
      const [candles,setCandles]=useState([]); const [sig,setSig]=useState(null);
      const [loading,setLoading]=useState(false); const [err,setErr]=useState("");
      const mainRef=useRef(null), volRef=useRef(null), rsiRef=useRef(null), macdRef=useRef(null);

      async function load(){ try{
        setLoading(true); setErr(""); setJSON(LS.LAST,{symbol,tf});
        const data=await fetchCandlesCombined(symbol,tf);
        let htfSide=null;
        if(tf!=="1D"){
          try{ const d1 = await fetchCandlesCombined(symbol,"1D"); htfSide = evaluate(d1,"1D",null)?.status || null; }catch(_){}
        }
        setCandles(data); setSig(evaluate(data,tf,htfSide));
      }catch(e){ setErr(String(e?.message||e)); setCandles([]); setSig(null);} finally{ setLoading(false);} }
      useEffect(()=>{ load(); },[symbol,tf]);

      // Charts
      useEffect(()=>{(async()=>{
        if(!candles.length||!mainRef.current) return;
        const LWC=await ensureLW();
        [mainRef,volRef,rsiRef,macdRef].forEach(r=>r.current&&(r.current.innerHTML=""));
        const first=0,last=candles.length-1;
        const clampScale=(ts)=>{ ts.subscribeVisibleLogicalRangeChange((range)=>{ if(!range) return; const maxTo=last+0.01,minFrom=first-0.01; let from=range.from,to=range.to,width=to-from; if(to>maxTo){to=maxTo;from=to-width;} if(from<minFrom){from=minFrom;to=from+width;} try{ts.setVisibleLogicalRange({from,to});}catch{} const key=`${symbol}|${tf}`; const ranges=getJSON(LS.RANGE,{}); ranges[key]={from,to}; setJSON(LS.RANGE,ranges); }); };

        const chart=LWC.createChart(mainRef.current,{width:Math.max(320,mainRef.current.clientWidth||900),height:430,layout:{background:{color:"#0b1220"},textColor:"#cbd5e1"},grid:{vertLines:{color:"#111827"},horzLines:{color:"#111827"}},rightPriceScale:{borderColor:"#1f2937"},timeScale:{borderColor:"#1f2937",rightOffset:0,fixLeftEdge:true,fixRightEdge:true},crosshair:{mode:1}});
        const lastPrice=candles[candles.length-1]?.close||1;
        const prec=pricePrecisionFromValue(lastPrice||1), minMove=Number((1/10**prec).toFixed(prec));
        const k=chart.addCandlestickSeries({upColor:"#16a34a",downColor:"#dc2626",wickUpColor:"#16a34a",wickDownColor:"#dc2626",borderVisible:true,borderUpColor:"#1a3d29",borderDownColor:"#4a1d1d",priceFormat:{type:"price",precision:prec,minMove}});
        k.setData(candles.map(c=>({time:c.time,open:c.open,high:c.high,low:c.low,close:c.close})));
        const ema50=ema(candles.map(c=>c.close),50);
        const emaS=chart.addLineSeries({color:"rgba(96,165,250,0.75)",lineWidth:2,priceLineVisible:false,lastValueVisible:false,priceFormat:{type:"price",precision:prec,minMove}});
        emaS.setData(candles.map((c,i)=>({time:c.time,value:ema50[i]})));
        const sl=sig;

        const addPL=(p,label,color)=>{ if(p==null||!isFinite(p))return; if(typeof k.createPriceLine==="function"){ k.createPriceLine({price:p,color,lineWidth:1,axisLabelVisible:true,title:label}); } else { const ls=chart.addLineSeries({color,lineWidth:1}); ls.setData(candles.map(c=>({time:c.time,value:p}))); } };
        addPL(sl?.recentHigh30,"H(30)","#22c55e"); addPL(sl?.recentLow30,"L(30)","#f59e0b"); addPL(sl?.recentHigh90,"H(90)","#22c55e"); addPL(sl?.recentLow90,"L(90)","#f59e0b");
        if(sl?.tps){ addPL(sl.tps.SL,"SL","#ef4444"); addPL(sl.tps.TP,"TP","#10b981"); }

        const key=`${symbol}|${tf}`, saved=getJSON(LS.RANGE,{}); if(saved){ try{ chart.timeScale().setVisibleLogicalRange(saved);}catch{ chart.timeScale().fitContent(); } } else { chart.timeScale().fitContent(); try{ chart.timeScale().setRightOffset(0);}catch{} }
        clampScale(chart.timeScale());

        const volC=LWC.createChart(volRef.current,{width:Math.max(320,volRef.current.clientWidth||900),height:120,layout:{background:{color:"#0b1220"},textColor:"#9ca3af"},grid:{vertLines:{color:"#0f172a"},horzLines:{color:"#0f172a"}},rightPriceScale:{borderColor:"#0f172a"},timeScale:{borderColor:"#0f172a",rightOffset:0,fixLeftEdge:true,fixRightEdge:true}});
        const volS=volC.addHistogramSeries({base:0,color:"#1f2937"});
        volS.setData(candles.map(c=>({time:c.time,value:c.volume,color:c.close>=c.open?"#15803d":"#b91c1c"})));
        const savedV=getJSON(LS.RANGE,{}); if(savedV){ try{ volC.timeScale().setVisibleLogicalRange(savedV);}catch{ volC.timeScale().fitContent(); } } else volC.timeScale().fitContent();
        clampScale(volC.timeScale());

        const rsiC=LWC.createChart(rsiRef.current,{width:Math.max(320,rsiRef.current.clientWidth||900),height:110,layout:{background:{color:"#0b1220"},textColor:"#93c5fd"},grid:{vertLines:{color:"#0f172a"},horzLines:{color:"#0f172a"}},rightPriceScale:{borderColor:"#0f172a"},timeScale:{borderColor:"#0f172a",rightOffset:0,fixLeftEdge:true,fixRightEdge:true}});
        const r=rsi(candles.map(c=>c.close),14); const rS=rsiC.addLineSeries({color:"#93c5fd",lineWidth:1});
        rS.setData(candles.map((c,i)=>({time:c.time,value:r[i]??null})));
        const r70=rsiC.addLineSeries({color:"#ef4444",lineWidth:1}), r30=rsiC.addLineSeries({color:"#22c55e",lineWidth:1});
        r70.setData(candles.map(c=>({time:c.time,value:70}))); r30.setData(candles.map(c=>({time:c.time,value:30})));
        const savedR=getJSON(LS.RANGE,{}); if(savedR){ try{ rsiC.timeScale().setVisibleLogicalRange(savedR);}catch{ rsiC.timeScale().fitContent(); } } else rsiC.timeScale().fitContent();
        clampScale(rsiC.timeScale());

        const macdC=LWC.createChart(macdRef.current,{width:Math.max(320,macdRef.current.clientWidth||900),height:130,layout:{background:{color:"#0b1220"},textColor:"#e5e7eb"},grid:{vertLines:{color:"#0f172a"},horzLines:{color:"#0f172a"}},rightPriceScale:{borderColor:"#0f172a"},timeScale:{borderColor:"#0f172a",rightOffset:0,fixLeftEdge:true,fixRightEdge:true}});
        const {line:M,sig:S,hist:H}=macd(candles.map(c=>c.close),12,26,9);
        const mL=macdC.addLineSeries({color:"#60a5fa",lineWidth:1});
        const sL=macdC.addLineSeries({color:"#f97316",lineWidth:1});
        const hS=macdC.addHistogramSeries({base:0,scaleMargins:{top:0.7,bottom:0}});
        mL.setData(candles.map((c,i)=>({time:c.time,value:M[i]??null})));
        sL.setData(candles.map((c,i)=>({time:c.time,value:S[i]??null})));
        hS.setData(candles.map((c,i)=>({time:c.time,value:H[i]??0,color:(H[i]??0)>=0?"#10b981":"#ef4444"})));
        const savedM=getJSON(LS.RANGE,{}); if(savedM){ try{ macdC.timeScale().setVisibleLogicalRange(savedM);}catch{ macdC.timeScale().fitContent(); } } else macdC.timeScale().fitContent();
        clampScale(macdC.timeScale());

        let syncing=false; const sync=(src,targets)=>{ src.subscribeVisibleLogicalRangeChange((rng)=>{ if(!rng||syncing) return; syncing=true; try{ targets.forEach(ts=>ts.setVisibleLogicalRange(rng)); }catch{} syncing=false; }); };
        const tsP=chart.timeScale(), tsV=volC.timeScale(), tsR=rsiC.timeScale(), tsM=macdC.timeScale();
        sync(tsP,[tsV,tsR,tsM]); sync(tsV,[tsP,tsR,tsM]); sync(tsR,[tsP,tsV,tsM]); sync(tsM,[tsP,tsV,tsR]);

        const resize=()=>{ chart.applyOptions({width:mainRef.current.clientWidth||900}); volC.applyOptions({width:volRef.current.clientWidth||900}); rsiC.applyOptions({width:rsiRef.current.clientWidth||900}); macdC.applyOptions({width:macdRef.current.clientWidth||900}); };
        const obs=new ResizeObserver(resize); [mainRef,volRef,rsiRef,macdRef].forEach(r=>r.current&&obs.observe(r.current)); requestAnimationFrame(resize);
      })()},[candles,symbol,tf,sig]);

      const colorAction=sig?.status==="Long"?"#16a34a":sig?.status==="Short"?"#dc2626":"#9ca3af";

      return (
        <div className="min-h-screen bg-gray-900 text-gray-100 font-sans">
          {/* Header */}
          <div className="sticky top-0 z-40 backdrop-blur bg-gray-900/90 border-b border-gray-800">
            <div className="px-4 md:px-6 py-3 flex items-center gap-3">
              <h1 className="text-2xl font-extrabold text-emerald-400">⚙️ Crypto Futures</h1>
              <select className="bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm" value={symbol} onChange={e=>setSymbol(e.target.value)}>
                {ALL_SYMBOLS.map(s=><option key={s}>{s}</option>)}
              </select>
              <select className="bg-gray-800 border border-gray-700 rounded px-3 py-2 text-sm" value={tf} onChange={e=>setTf(e.target.value)}>
                <option value="4H">4H</option><option value="1D">1D</option><option value="1W">1W</option><option value="1M">1M</option>
              </select>
              <button className="bg-indigo-600 hover:bg-indigo-500 rounded px-4 py-2 text-sm font-semibold" onClick={load} disabled={loading}>
                {loading?"Actualizando…":"Actualizar datos"}
              </button>
              <div className="ml-auto text-sm text-gray-300">Precio: <b>{fmtDyn(lastOf(candles)?.close)}</b></div>
            </div>
          </div>

          {/* Panel superior */}
          <div className="px-4 md:px-6 py-4">
            <div className="grid lg:grid-cols-2 gap-4">
              {/* Señal */}
              <div className="bg-gray-800 border border-gray-700 rounded-xl p-5">
                <div className="flex items-center gap-2 mb-2"><div className="w-3 h-3 rounded bg-emerald-400"/><h2 className="text-lg font-semibold">Señal</h2></div>
                {sig ? <>
                  <div className="flex flex-wrap items-center gap-3">
                    <span className="text-2xl font-extrabold" style={{color:colorAction}}>{sig.status}</span>
                    <span className="text-sm text-gray-400">Sesgo: <b>{sig.bias}</b></span>
                    <span className="text-sm text-gray-400">Fiabilidad: <b>{((sig.reliability??0)*100).toFixed(1)}%</b></span>
                  </div>
                  {sig.active && <div className="mt-2 text-amber-300 text-sm font-semibold">{sig.active.text}</div>}

                  {/* ENTRADA + TP + SL */}
                  {sig.tps && (
                    <div className="grid md:grid-cols-3 gap-3 text-sm mt-4">
                      <div><div className="text-gray-400">Entrada</div><div className="font-semibold">{fmtDyn(sig.active?.entry)}</div></div>
                      <div><div className="text-gray-400">TP</div><div className="font-semibold">{fmtDyn(sig.tps.TP)}</div></div>
                      <div><div className="text-gray-400">SL</div><div className="font-semibold">{fmtDyn(sig.tps.SL)}</div></div>
                    </div>
                  )}

                  <div className="mt-4">
                    <div className="mb-1 text-gray-300 font-semibold">Por qué</div>
                    {sig.why?.length ? <ul className="list-disc pl-5 text-gray-300">{sig.why.map((p,i)=><li key={i}>{p}</li>)}</ul> : <div className="text-gray-400">—</div>}
                  </div>
                </> : <div className="text-sm text-gray-400">—</div>}
              </div>

              {/* Lectura técnica + comentario */}
              <div className="bg-gray-800 border border-gray-700 rounded-xl p-5">
                <div className="flex items-center gap-2 mb-2"><div className="w-3 h-3 rounded bg-sky-400"/><h2 className="text-lg font-semibold">Lectura técnica</h2></div>
                {sig ? <div className="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                  <p>EMA50: <b>{fmtDyn(sig.ema50)}</b></p>
                  <p>RSI(14): <b>{fmtNum(sig.rsi14,2)}</b></p>
                  <p>MACD: <b>{fmtNum(sig.macd,6)}</b></p>
                  <p>Signal: <b>{fmtNum(sig.signal,6)}</b></p>
                  <p>Hist: <b>{fmtNum(sig.hist,6)}</b></p>
                  <p>H/L(30): <b>{fmtDyn(sig.recentHigh30)} / {fmtDyn(sig.recentLow30)}</b></p>
                  <p>H/L(90): <b>{fmtDyn(sig.recentHigh90)} / {fmtDyn(sig.recentLow90)}</b></p>
                  <p>Fiabilidad: <b>{((sig.reliability??0)*100).toFixed(1)}%</b></p>
                  <p className="col-span-2 text-xs text-gray-400 mt-1">Condición: EMA50 + RSI/MACD + volumen. Solo velas cerradas.</p>
                  <p className="col-span-2 text-sm text-gray-300 mt-2"><span className="font-semibold">Comentario:</span> {sig.commentary}</p>
                </div> : <div className="text-sm text-gray-400">—</div>}
              </div>
            </div>
          </div>

          {/* Ideas */}
          <div className="px-4 md:px-6 pb-2">
            <div className="bg-gray-800 border border-gray-700 rounded-xl p-5">
              <div className="text-sm font-semibold text-amber-400">Posibles operaciones (entrada inmediata)</div>
              <div className="text-xs text-gray-400 mb-3">Cálculos a precio actual con SL/TP por ATR y niveles. Solo para fines educativos.</div>
              {sig?.ideas?.length ? <div className="grid md:grid-cols-2 gap-3">
                {sig.ideas.map((id,k)=>(<div key={k} className="border border-gray-700 rounded-lg p-3">
                  <div className="flex items-center gap-2 mb-1">
                    <b className="text-sm">{id.dir}</b>
                    <span className={"text-[11px] px-2 py-0.5 rounded-full border "+(id.reliability<0.45?"bg-red-500/10 text-red-300 border-red-500/30":id.reliability<0.60?"bg-amber-500/10 text-amber-300 border-amber-500/30":"bg-emerald-500/10 text-emerald-300 border-emerald-500/30")} title="Confluencia (EMA/RSI/MACD/Volumen) + 1D">
                      {id.reliability<0.45?"Alto riesgo":id.reliability<0.60?"Riesgo medio":"Riesgo controlado"}
                    </span>
                    <span className="ml-auto text-xs text-gray-400">Fiabilidad: <b className="text-gray-200">{(id.reliability*100).toFixed(1)}%</b></span>
                  </div>
                  <div className="grid grid-cols-3 gap-2 text-sm">
                    <div><div className="text-gray-400">Entrada</div><div className="font-semibold">{fmtDyn(id.entry)}</div></div>
                    <div><div className="text-gray-400">SL</div><div className="font-semibold">{fmtDyn(id.sl)}</div></div>
                    <div><div className="text-gray-400">TP</div><div className="font-semibold">{fmtDyn(id.tp)}</div></div>
                  </div>
                  <div className="mt-1 text-xs text-gray-400">R/R: <b>{fmtNum(id.rr,2)}</b> — TP media (2R + nivel), SL humano.</div>
                </div>))}
              </div> : <div className="text-sm text-gray-400">Sin ideas en este momento.</div>}
            </div>
          </div>

          {/* Charts */}
          <div className="px-4 md:px-6 pb-8">
            <div className="bg-gray-800 border border-gray-700 rounded-xl p-3 mb-3"><div ref={mainRef} style={{width:"100%",height:430}}/></div>
            <div className="bg-gray-800 border border-gray-700 rounded-xl p-3 mb-3"><h3 className="text-xs text-gray-400 mb-1">Volumen</h3><div ref={volRef} style={{width:"100%",height:120}}/></div>
            <div className="bg-gray-800 border border-gray-700 rounded-xl p-3 mb-3"><h3 className="text-sm text-gray-300 mb-1">RSI (14)</h3><div ref={rsiRef} style={{width:"100%",height:110}}/></div>
            <div className="bg-gray-800 border border-gray-700 rounded-xl p-3"><h3 className="text-sm text-gray-300 mb-1">MACD (12,26,9)</h3><div ref={macdRef} style={{width:"100%",height:130}}/></div>
            {err && <div className="text-red-400 mt-4">{err}</div>}
          </div>
        </div>
      );
    }

    window.__startApp__ = function startApp(){
      try{ ReactDOM.createRoot(document.getElementById("root")).render(<App />); }
      catch(e){ console.error(e); showFatal(e); }
    };
  </script>
</body>
</html>
